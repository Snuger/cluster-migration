using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Cyan_Service_Migration.Services
{
    public class ScheduledTaskService : IHostedService, IDisposable
    {
        private readonly ILogger<ScheduledTaskService> _logger;
        private readonly ScheduledTaskSettings _settings;
        private Timer? _timer;
        private string _logDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
        private readonly string _shellScriptPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "migration.sh");

        public ScheduledTaskService(ILogger<ScheduledTaskService> logger, IOptions<ScheduledTaskSettings> settings)
        {
            _logger = logger;
            _settings = settings.Value;
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("Scheduled task service is starting.");

            if (!_settings.IsEnabled)
            {
                _logger.LogInformation("Scheduled task is disabled in configuration.");
                return Task.CompletedTask;
            }

            var (delay, interval) = CalculateTimerSettings();
            _timer = new Timer(ExecuteTask, null, delay, interval);

            _logger.LogInformation("Scheduled task configured with {mode} mode. Next run in {delay}",
                _settings.ExecutionMode,
                delay);

            return Task.CompletedTask;
        }

        private (TimeSpan delay, TimeSpan interval) CalculateTimerSettings()
        {
            var now = DateTime.Now;
            TimeSpan delay;
            TimeSpan interval;

            switch (_settings.ExecutionMode)
            {
                case TaskExecutionMode.Interval:
                    delay = TimeSpan.Zero; // Start immediately
                    interval = TimeSpan.FromMinutes(_settings.IntervalMinutes);
                    break;

                case TaskExecutionMode.Daily:			
		var fallbackTime = _settings.ExecutionTime;
		//_logger.LogInformation("Using configured execution time: {ExecutionTime}", fallbackTime.ToString("hh:mm:ss"));
		var fallbackFirstRun = now.Date.Add(fallbackTime);
			if (now > fallbackFirstRun)
			{
				fallbackFirstRun = fallbackFirstRun.AddDays(1);
			}
			delay = fallbackFirstRun - now;
			interval = TimeSpan.FromDays(1);

			break;

                default: // TaskExecutionMode.Daily as fallback
                    var fallbackTime2 = new TimeSpan(18, 0, 0);
                    var fallbackFirstRun2 = now.Date.Add(fallbackTime2);
                    if (now > fallbackFirstRun2)
                    {
                        fallbackFirstRun2 = fallbackFirstRun2.AddDays(1);
                    }
                    delay = fallbackFirstRun2 - now;
                    interval = TimeSpan.FromDays(1);
                    break;
            }

            return (delay, interval);
        }

        private string GetLogFilePath()
        {
            // Create directory if it doesn't exist
            if (!Directory.Exists(_logDirectory))
            {
                Directory.CreateDirectory(_logDirectory);
            }
              
            // Generate filename with timestamp
            string timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
            return Path.Combine(_logDirectory, $"migration_{timestamp}.log");
        }

        private void ExecuteTask(object state)
        {
            _logger.LogInformation("Executing scheduled task at {time}", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
			string logFilePath = GetLogFilePath();

			try
            {
                // Log file path will be generated by GetLogFilePath()
                

                // Execute shell command
                var processInfo = new ProcessStartInfo
                {
                    FileName = "/bin/bash",
                    Arguments = _shellScriptPath,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using (var process = Process.Start(processInfo))
                using (var reader = process.StandardOutput!)
                using (var errorReader = process.StandardError!)
                {
                    string output = reader.ReadToEnd();
                    string error = errorReader.ReadToEnd();
                    process.WaitForExit();
                    // Write to log file with timestamp                   
                    using (var writer = new StreamWriter(logFilePath))
                    {
                        writer.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] Task executed with exit code: {process.ExitCode}");
                        if (!string.IsNullOrEmpty(output))
                        {
                            writer.WriteLine("Output:");
                            writer.WriteLine(output);
                        }
                        if (!string.IsNullOrEmpty(error))
                        {
                            writer.WriteLine("Error:");
                            writer.WriteLine(error);
                        }
                        writer.WriteLine(new string('-', 50)); // Separator
                    }

                    if (process.ExitCode != 0)
                    {
                        _logger.LogError("Scheduled task failed with exit code {exitCode}. Error: {error}", process.ExitCode, error);
                    }
                    else
                    {
                        _logger.LogInformation("Scheduled task completed successfully");
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error executing scheduled task");
                // Write exception to log file              
                using (var writer = new StreamWriter(logFilePath))
                {
                    writer.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] Exception occurred:");
                    writer.WriteLine(ex.ToString());
                    writer.WriteLine(new string('-', 50));
                }
            }
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("Scheduled task service is stopping.");
            _timer?.Change(Timeout.Infinite, 0);
            return Task.CompletedTask;
        }

        public void Dispose()
        {
            _timer?.Dispose();
        }
    }
}